class ForceDirectedGraph {

    /**
     * Class constructor with basic chart configuration
     * @param {Object}
     * @param {Array}
     */
    constructor(_config, _data) {
        this.config = {
          parentElement: _config.parentElement,
          containerWidth: window.innerWidth,
          containerHeight: window.innerHeight * 0.8,
          margin: {top: 25, right: 20, bottom: 20, left: 35},
          tooltipPadding: 10
        }
        this.data = _data;
        this.initVis();
        this.selectedNode = null;
      }

      initVis(){
        let vis = this;
  
        vis.config.width = vis.config.containerWidth - vis.config.margin.left - vis.config.margin.right;
        vis.config.height = vis.config.containerHeight - vis.config.margin.top - vis.config.margin.bottom;

        vis.colorScale = d3.scaleOrdinal(d3.schemeCategory10);//ADD COLORSCALE
    
        vis.svg = d3.select(vis.config.parentElement).append('svg')
          .attr('width', vis.config.containerWidth-500) //decreasing svg size since moved over from menus
          .attr('height', vis.config.containerHeight);

        vis.chart = vis.svg.append('g')
          .attr('transform', `translate(${vis.config.margin.left},${vis.config.margin.top})`);
        
        vis.simulation = d3.forceSimulation()
          .force('link', d3.forceLink()
            .id(d => d.id)
            .distance(100)
            .strength(0.04))
          .force('charge', d3.forceManyBody())
          .force('center', d3.forceCenter((vis.config.width - 500) / 2, vis.config.height / 2));
      
        //ChatGPT assisted, helping with clicking off node by clicking svg
        vis.svg.on('click', function(event) {
          if (event.target.tagName === 'svg') {
            vis.chart.selectAll('circle').style('opacity', 1).classed('active', false);
            vis.chart.selectAll('line').style('opacity', 1);


            const dropdown = d3.select("#neighbors");
            dropdown.selectAll('option').remove();

            const current = d3.select("#current");
            current.selectAll('option').remove();

            current.append('option')
              .text("None");
          }
        });
        //end of ChatGPT
        
        vis.updateVis();
      }

      updateVis() {
        let vis = this;
    
        vis.simulation.nodes(vis.data.nodes);
        vis.simulation.force('link').links(vis.data.links);
        
        //Code below Generated by ChatGPT, helping with coding the neighbor nodes
        vis.data.nodes.forEach(node => node.neighbors = []);
        vis.data.links.forEach(link => {
          const source = typeof link.source === "object" ? link.source : vis.data.nodes.find(n => n.id === link.source);
          const target = typeof link.target === "object" ? link.target : vis.data.nodes.find(n => n.id === link.target);
          source.neighbors.push(target);
          target.neighbors.push(source);
        });
        //end of ChatGPT

        vis.renderVis();
  
        console.log('Nodes:', vis.data.nodes); //DEBUGGING
        console.log('Links:', vis.data.links);
      }
    
      renderVis() {
        let vis = this;
      
        const links = vis.chart.selectAll('line')
          .data(vis.data.links, d => `${d.source}-${d.target}`) // Unique string key
          .join('line')
          .attr('stroke', d => 
            d.type === "Z" ? '#fb9a99' : 
            d.type === "Y" ? "#33a02c" : "#ddd");
      
        const nodes = vis.chart.selectAll('circle')
          .data(vis.data.nodes, d => d.id)
          .join('circle')
          .attr('r', d => 3 * Math.log10(d.size) + 4)
          .attr("fill", d =>
            d.id === "Super Smash Bros. Ultimate" ? "#636363" :
            d.party === "Y" ? "#d7191c" :
            "#2c7bb6" 
          )
          .attr('tabindex', '0')
          .call(d3.drag() //DRAG CALL
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
      
        nodes
          .on('mouseover', (event, d) => showTooltip(event, d)) //shows tooltip when mouseover
          .on('mouseout', hideTooltip) //hides tooltip 

          .on('focus', function(event, d) { //shows tooltip if enter is tabbed (accesibility)
              const node = this.getBoundingClientRect();

              //part below assisted by ChatGPT
              const fakeEvent = {
                pageX: node.left + window.scrollX + node.width / 2,
                pageY: node.top + window.scrollY + node.height / 2
              };//end of assistance 

              showTooltip(fakeEvent, d)
          })

          .on('blur', (event, d) => hideTooltip) //hides tooltip when tabbed off
          
          .on('keydown', function(event, d) { //shows neighbors if enter is pressed (accesibility)
            if (event.key === "Enter") {
              
              highlightNeighbors(event, d)
              event.stopPropagation(); // Prevent event from bubbling up to SVG
            }

            if (event.key === "Backspace") {
    
              //resets all nodes/links
              vis.chart.selectAll('circle').style('opacity', 1).classed('active', false);
              vis.chart.selectAll('line').style('opacity', 1);

              const dropdown = d3.select("#neighbors");
              dropdown.selectAll('option').remove();

              const current = d3.select("#current");
              current.selectAll('option').remove();

              current.append('option')
                .text("None");

              
            }
          })
          
          .on('click', (event, clickedNode) => {
            
            highlightNeighbors(event, clickedNode);
            event.stopPropagation(); // Prevent event from bubbling up to SVG
            
          });
          
          //ChatGPT assisted
          function highlightNeighbors(event, clickedNode) {
            if (vis.selectedNode === clickedNode) { // if repeat node
              vis.selectedNode = null;
              resetSelect();
            } else {
              vis.selectedNode = clickedNode; // set new node
              const neighbors = new Set(clickedNode.neighbors.map(d => d.id));
              neighbors.add(clickedNode.id); // Include clicked node itself
            
              const sortedNeighbors = clickedNode.neighbors
                .sort((a, b) => b.size - a.size);

              const dropdown = d3.select("#neighbors");
              dropdown.selectAll('option').remove();

              const current = d3.select("#current");
              current.selectAll('option').remove();

              current.append('option')
                .text(`${clickedNode.id}`);

              sortedNeighbors.forEach(neighbor => {
              dropdown.append('option')
                .attr('value', neighbor.id)
                .text(`${neighbor.id}: ${neighbor.size}M copies sold`);
              });

              nodes
                .style('opacity', d => neighbors.has(d.id) ? 1 : 0.1)
                .classed('active', d => d.id === clickedNode.id);
          
              links
                .style('opacity', l => {
                  const sourceId = typeof l.source === "object" ? l.source.id : l.source;
                  const targetId = typeof l.target === "object" ? l.target.id : l.target;
                  return neighbors.has(sourceId) && neighbors.has(targetId) ? 1 : 0.1;
                 });
              }
          }
          //end of ChatGPT assistance

          function resetSelect() {
            nodes
              .style('opacity', 1)
              .classed('active', false);
          
            links
              .style('opacity', 1);

            const dropdown = d3.select("#neighbors");
            dropdown.selectAll('option').remove();

            const current = d3.select("#current");
            current.selectAll('option').remove();

            current.append('option')
              .text("None");
          
          }
      
        vis.simulation.on('tick', () => {
          links
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
      
          nodes
            .attr('cx', d => d.x)
            .attr('cy', d => d.y)
        });
      
        function dragstarted(event, d) {
          if (!event.active) vis.simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }
      
        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }
      
        function dragended(event, d) {
          if (!event.active) vis.simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;

        }

        function showTooltip(event, d) {
          d3.select('#tooltip')
            .style('display', 'block')
            .style('left', (event.pageX + vis.config.tooltipPadding) + 'px')
            .style('top', (event.pageY + vis.config.tooltipPadding) + 'px')
            .html(`
              <div class="tooltip-title"><strong>Franchise: </strong>${d.id}</div>
              <div><i>Estimated Copies Sold (Millions): </i>${d.size}</div>
              <div><i>Main Genre: </i>${d.genre}</div>
              <div><i>Number of Crossovers: </i>${d.neighborCount}</div>
            `);
        }

        function hideTooltip() {
          d3.select('#tooltip').style('display', 'none');
        }

      }

}